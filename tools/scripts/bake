#!/usr/bin/env bash
#
#############################################################################
#############################################################################
#
# bake: a complete and deterministic environment for the standard upstream
#           build and compose tools (koji/pungi/livecd-creator)
#
#############################################################################
#
# Copyright 2007-2011 Douglas McClendon <dmc AT filteredperception DOT org>
#
#############################################################################
#
# This file is part of X.
#
#    X is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    X is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with X.  If not, see <http://www.gnu.org/licenses/>.
#
#############################################################################
# note: if you'd like a different license, just let me know which and why
#############################################################################


#############################################################################
#############################################################################
##
## bake
##
##
## DESCRIPTION
##
## bake takes as input network or offline access to a bootstrapping
## enterprise linux distro (e.g. SL60/F13) and recently built set of distro
## packages (e.g. from koji), and outputs a new installable distro repotree
## (e.g. ASC60) suitable for mirroring to the masses.
##
##
## LONG TERM ROADMAP
##
## - the input pipeline will be expanded to include:
##  - use gen-tdv-srpm-repos to create the input srpms from the dev/git tree
##  - invoking makeworld/koji to generate what is the current input
##
##
## NOTES
##
## - output reproducibility is ensured by the fact that a disposable VM
##   is generated and used for the major processing phases (e.g. pungi,
##   and later koji).
##
## - el-build host requirements (or, what the devoloper has)
##  - x86_64 2 core system, 4G of ram
##  - 200G tmp disk space, 30G for final output
##
#############################################################################


#############################################################################
#############################################################################
##
## TODO
# - factor main into several large independent functions, 1 per bake phase
# - add option bootstrap_distro_tree=...sl60x64
#  - and in general factor all configuration into proper configuration
# - ...
#


#############################################################################
#############################################################################
##
## local constant definitions
##

# for common script library- libx.sh
x_toolname="el-build"
x_prefix=/usr


#############################################################################
#############################################################################
##
## load system library
##

if [ -f "$( dirname $( readlink -e $0 ) )/../../tools/scripts/libx.sh" ]; then
    source "$( dirname $( readlink -e $0 ) )/../../tools/scripts/libx.sh"
elif [ -f "${x_prefix}/lib/${x_toolname}/scripts/libx.sh" ]; then 
    source "${x_prefix}/lib/${x_toolname}/scripts/libx.sh" 
else
    echo "$0: error: fatal: could not load ${x_toolname} system library libx.sh"
    exit 1
fi


#############################################################################
#############################################################################
##
## constant and option default definitions
##

builtrepo_def="${x_bake_builtrepo}"
distroname_def="${x_bake_distroname}"
distrover_def="${x_bake_distrover}"
offline_def="${x_bake_offline}"
do_bake_phases_def="${x_bake_do_bake_phases}"
bake_flags_def="${x_bake_bake_flags}"
test_package_list_def="${x_bake_test_package_list}"
distrorelname_def="${x_bake_distrorelname}"
# presumption is to first check in ./, then x_devdir/6/distrover/
config_x64_def="${x_bake_config_x64}"
config_x32_def="${x_bake_config_x32}"
outputdir_def="${x_bake_outputdir}"
homedotdir_def="${x_bake_homedotdir}"
cachedir_def="${x_bake_cachedir}"
bake_tmpdir_def="${x_bake_tmpdir}"
clear_bootstrapos_repodata_def="${x_bake_clear_bootstrapos_repodata}"

# to enable debug messages if desired
x_debug=1

# to suppress status messages if desired
x_quiet=0


#############################################################################
#############################################################################
##
## functions
##
function usage {
    echo ""
    echo "usage:"
    echo ""
    echo "${progname} \\"
    echo "    [distroname=${distroname_def}] \\"
    echo "    [distrover=${distrover_def}] \\"
    echo "    [offline=${offline_def}] \\"
    echo "    [do_bake_phases=${do_bake_phases_def}] \\"
    echo "    [bake_flags=${bake_flags_def}] \\"
    echo "    [test_package_list=${test_package_list_def}] \\"
    echo "    [distrorelname=${distrorelname_def}] \\"
    echo "    [config_x64=${config_x64_def}] \\"
    echo "    [config_x32=${config_x32_def}] \\"
    echo "    [outputdir=${outputdir_def}] \\"
    echo "    [cachedir=${cachedir_def}] \\"
    echo "    [bake_tmpdir=${bake_tmpdir}_def}] \\"
    echo "    [builtrepo=${builtrepo_def}]"
    echo ""
    echo "All arguments are optional, with default values shown as above."
    echo ""
    echo "some development/debug options are-"
    echo "    [clear_bootstrapos_repodata=${clear_bootstrapos_repodata_def}]"
    echo ""
    echo ""
    exit 1
}


#############################################################################
#############################################################################
##
## main
##

status "initializing..."

# note: presumption is that el-build is run from within it's own
#       developtment tree, or a symlink to it.  e.g. 
# $ ./relative/path/to/Ascendos/tools/el-build/el-build or $ ./el-build

#############################################################################
#
## set option value defaults
#
distroname="${distroname_def}"
distrover="${distrover_def}"
offline="${offline_def}"
do_bake_phases="${do_bake_phases_def}"
bake_flags="${bake_flags_def}"
test_package_list="${test_package_list_def}"
clear_bootstrapos_repodata="${clear_bootstrapos_repodata}"
distrorelname="${distrorelname_def}"
config_x64="${config_x64_def}"
config_x32="${config_x32_def}"
outputdir="${outputdir_def}"
homedotdir="${homedotdir_def}"
cachedir="${cachedir_def}"
bake_tmpdir="${bake_tmpdir_def}"
builtrepo="${builtrepo_def}"


#############################################################################
#
## process command line arguments / options
#
status "processing options..."
# this is a simple enough method for a first pass.  I'd have brought in
# viros's libvopt.sh if it wasn't so complex.
for option in "$@"; do
    if [ "${option}" == "usage" ]; then
	usage
    elif [ "${option}" == "--usage" ]; then
	usage
    elif [ "${option}" == "help" ]; then
	usage
    fi
    if $( echo "${option}" | grep -q "=" ); then
	# simplest
#	eval "${option}"
	# a bit better, allows e.g. distroname="Two Words"
	# (though a two word distroname is as yet untested and may not work anyway)
	opt_name=$( echo "${option}" | sed -e 's/=.*//' )
	opt_val=$( echo "${option}" | sed -e 's/[^=]*=//' )
	eval "${opt_name}='${opt_val}'"
    else
	status "option '${option}' is invalid, options must be of the form 'option_name=option_value'"
	usage
    fi
    debug "opt is $option"
done


if ( ! mkdir -p "${outputdir}" > /dev/null 2>&1 ); then
    die "output directory - ${outputdir} - could not be made"
fi

bvm_tmpdir="${bake_tmpdir}/${starttime}.${mypid}.vm"
if ( ! mkdir -p "${bvm_tmpdir}" > /dev/null 2>&1 ); then
    die "temp directory - ${bvm_tmpdir} - could not be made"
fi


#############################################################################
#
## clean stale state from prior runs
#

status "cleaning away residue from prior cooks ..."

num_bakers=$( virsh list --all \
    | awk '{print $2}' \
    | grep "^bake" \
    | wc -l )

num_stale_bakes=$( \
    echo "${num_bakers} - ${x_keep_old_baker_vm_definitions}" \
    | bc -l )

stale_bakes=$( virsh list --all \
    | awk '{print $2}' \
    | grep "^bake" \
    | sort \
    | head "-${num_stale_bakes}" )

for stale_bake in ${stale_bakes}; do

    status "saving xml for stale bake vm ${stale_bake} ..."
    virsh \
	dumpxml \
	"${stale_bake}" \
	> "${bvm_tmpdir}/.stale.baker_vm.${stale_baker}.xml" 2>&1

    status "undefining stale bake vm ${stale_bake} ..."
    virsh \
	undefine \
	"${stale_bake}" \
	> "${bvm_tmpdir}/.stale.baker_vm.${stale_baker}.undef.log" 2>&1

done

#############################################################################
#
## update mirrors / cache
#
status "updating cache / mirrors..."

# TODO: the bootstrapping OS needn't be full mirrored
#       (a script to mirror the needed parts of a repo from a .ks
#        would be very appreciated.  hint hint)
#       (or alternately and much more likely I'll just have a postprocessor
#        generated manifest subset of the current overkill mirror)

# use lftp for mirroring

# note: perhaps? pull instead from koji, or ascendos/everything 
#       (based on binary rpm name list generated from tuv srpm list)


if ( ! mkdir -p "${cachedir}" > /dev/null 2>&1 ); then
    die "cache directory (mirror root) - ${cachedir} - could not be used/made"
fi

cd "${cachedir}"

# TODO: support rsync as an option

if [ "${clear_bootstrapos_repodata}" == "yes" ]; then
    status "clearing out cached bootstrap OSs repodata"
    # pretty ugly workaround for some issue probably resolved by a prior bugfix, but
    # just in case it happens again, a reminder option.
    rm -rf ./ftp.scientificlinux.org___linux__scientific__6.0__i386__os/repo{data,view}
    rm -rf ./ftp.scientificlinux.org___linux__scientific__6.0__x86_64__os/repo{data,view}
    rm -rf ./ftp.scientificlinux.org___linux__scientific__6x__SRPMS/repo{data,view}
fi

if [ "${offline}" == "yes" ]; then
    status "offline mode: not updating cache / mirrors..."
else

    if ( ! ping -c3 mirrors.kernel.org > /dev/null 2>&1 ) then
        # presume offline intent if no net connection seemingly present
	status "can't ping mirrors.kernel.org, falling back to trying an offline from-cache build ..."
	offline=yes
    else

	status "invoking update-net-cache ${cachedir} ..."
	update-net-cache "${cachedir}"

        # note: ugly(?) temporary workaround that will be obsolete no later than the 
        #       time when koji/makeworld show up in el-build
        # todo: handle packaged installed case, i.e. not x_devdir relative, but... (and elsewhere)
	createrepo \
	    "${cachedir}/build.ascendos.org___linux__ascendos__SRPMS"
	createrepo \
	    -g "${x_devdir}/6/6.0/configs/comps-asc6-x86_64.xml" \
	    "${cachedir}/build.ascendos.org___linux__ascendos__6.0/os/x86_64" 
	createrepo \
	    -g "${x_devdir}/6/6.0/configs/comps-asc6-i386.xml" \
	    "${cachedir}/build.ascendos.org___linux__ascendos__6.0/os/i386" 

	# hmm?
	# ? workaround for mirroring epel at the wrong instant? (got a bad repodata error)
	createrepo \
	    "${cachedir}/mirrors.kernel.org___pub__fedora-epel__6__SRPMS"
	createrepo \
	    "${cachedir}/mirrors.kernel.org___pub__fedora-epel__6__i386"
	createrepo \
	    "${cachedir}/mirrors.kernel.org___pub__fedora-epel__6__x86_64"
	

    fi

fi



#############################################################################
#
## create multiarch repo structure usable by koji
#

# aka
debug "workaround around yum variable limitations ..."


# SHOWSTOPPER: hugh sigh, need to iterate over mirror dirs,
# and for each, look at each dep_bs_os, and see if it is
# a prefix/subset of self.  If it is, grab the dirname of 
# the suffix (e.g dirname(os/Packages) in the \$arch/os/ case,
# is os).  Then mkdir -p that parent directory under the 
# cachedir multiarchroot for that specific dep_bs_os.  Then
# make a symlink from the child, _still_ having to depth count
# for the sake of correct relative path.  Ack!

# TODO: make this less gross
mo_dependent_bootstrap_os_list="\
${x_dependent_bootstrap_os_list}
bao:http://build.ascendos.org/linux/ascendos/build/\$arch/
"

for dependent_bootstrap_os in ${mo_dependent_bootstrap_os_list}; do
    
    os_abbrev=$( echo "${dependent_bootstrap_os}" \
	| sed -e 's/:.*//' )
    showvar os_abbrev
    
    os_repo=$( echo "${dependent_bootstrap_os}" \
	| sed -e 's/[^:]*://' )
    showvar os_repo
    
    os_multiarch_repo_root=$( echo "${os_repo}" \
	| sed -e 's/\/$arch.*$//' )
    showvar os_multiarch_repo_root
    
    os_repo_suffix=$( echo "${os_repo}" \
	| sed -e 's/^.*$arch//' \
	| sed -e 's/__/\//g' \
	| sed -e 's/^\///' \
	| sed -e 's/\/$//' )
    showvar os_repo_suffix
    os_repo_suffix_xmog=$( echo "${os_repo_suffix}" \
	| sed -e 's/\//__/g' )
    showvar os_repo_suffix_xmog
    
    os_x32_repo=$( echo "${os_repo}" \
	| sed -e 's/$arch/i386/g' )
    showvar os_x32_repo
    
    os_x64_repo=$( echo "${os_repo}" \
	| sed -e 's/$arch/x86_64/g' )
    showvar os_x64_repo
    
    showvar os_multiarch_repo_root

    # TODO: make this less ugly
    mirror_dir=$( echo "${os_multiarch_repo_root}" \
	| sed -e 's#^http://10.0.2.2:8421/cache/##g' )
    showvar mirror_dir

    # TODO: last line is ugliness due to tiredness
    mirror_dir_xmog=$( echo "${mirror_dir}" \
	| sed -e 's/^.*:\/\///' \
	| sed -e 's/\//__/g' \
	| sed -e 's/__/___/' )

    showvar mirror_dir_xmog

    debug "special cache multiarch link root is: ${cachedir}/${mirror_dir_xmog} ..."

    rm -rf \
    	"${cachedir}/${mirror_dir_xmog}"
    mkdir -p \
    	"${cachedir}/${mirror_dir_xmog}"
    mkdir -p \
    	"${cachedir}/${mirror_dir_xmog}/i386"
    mkdir -p \
    	"${cachedir}/${mirror_dir_xmog}/x86_64"
    # TODO: sigh, number of ../ here needs to be generated/calculated
    ln -s \
	"../../${mirror_dir_xmog}__i386__${os_repo_suffix_xmog}" \
	"${cachedir}/${mirror_dir_xmog}/i386/${os_repo_suffix}"
    ln -s \
	"../../${mirror_dir_xmog}__x86_64__${os_repo_suffix_xmog}" \
	"${cachedir}/${mirror_dir_xmog}/x86_64/${os_repo_suffix}"
done


#############################################################################
#
## launch user-httpd on port 8421
#

# TODO: use random port between some range instead of static port

# note: one could also tar up the docroot into a new qemu disk image, and
#       use that to expose the data to the VM (or probably several other
#       ways, including non-userstack networking that may be faster)

# create directory for config/logs, and one for docroot
mkdir -p "${homedotdir}/vm-httpd/${starttime}.${mypid}.etc"
mkdir -p "${homedotdir}/vm-httpd/${starttime}.${mypid}.docroot"

# expose the mirrors / cache inside the docroot
ln -s ../../cache \
    "${homedotdir}/vm-httpd/${starttime}.${mypid}.docroot/cache"

status "launching user (non-root) httpd as a service for the inner processing vm ..."
# TODO: this should no doubt be narrowed, lazy big hammer for the first pass
killall httpd > /dev/null 2>&1
sleep 2
killall -KILL httpd > /dev/null 2>&1
sleep 2
# launch the httpd daemon
user-httpd \
    "${x_builder_user_httpd_port}" \
    "${homedotdir}/vm-httpd/${starttime}.${mypid}.docroot" \
    "${homedotdir}/vm-httpd/${starttime}.${mypid}.etc" \
    start


#############################################################################
#
## prepare network environment for the throwaway vm
#

if [ "${do_bake_phases}" == "all" ]; then
    do_bake_phases="\
compile-sources
installer-traditional-x32
installer-traditional-x64
installer-live-x32
installer-live-x64
stage-layout
"
fi


do_bake_phases=$( uncomma_list "${do_bake_phases}" )
bake_flags=$( uncomma_list "${bake_flags}" )
test_package_list=$( uncomma_list "${test_package_list}" )

# expose baking options to the inner/v-bake script
# TODO: probably a cleaner way
cat <<EOF > "${homedotdir}/vm-httpd/${starttime}.${mypid}.docroot/v-bake.options" 
do_bake_phases="${do_bake_phases}"
bake_flags="${bake_flags}"
test_package_list="${test_package_list}"
EOF

# todo: make the list of vars a list and iterate here and above
export do_bake_phases
export bake_flags
export test_package_list

debug "do_bake_phases option being passed to v-bake is: ${do_bake_phases} ..."
debug "bake_flags option being passed to v-bake is: ${bake_flags} ..."
debug "test_package_list option being passed to v-bake is: ${test_package_list} ..."

## expose inner processing script (x-run/v-bake) in the docroot
cp "${x_devdir}/tools/scripts/v-bake" \
    "${homedotdir}/vm-httpd/${starttime}.${mypid}.docroot/x-run" 

# TODO: now that devtree is passed down to vm, use it, ala other recent opt="6/6.0/...ks"

### create throwaway vm's .ks from template, placed in docroot
cp "${x_devdir}/${x_builder_vm_ks_config}" \
    "${homedotdir}/vm-httpd/${starttime}.${mypid}.docroot/baker.ks" 

status "preparing a full copy of the build tools devtree for the inner-vm to use ..."
### give a full copy of the devtree to the vm
tar -C $( dirname "${x_devdir}" ) -cjf \
    "${homedotdir}/vm-httpd/${starttime}.${mypid}.docroot/devtree.tar.bz2" \
    $( basename "${x_devdir}" )


#############################################################################
#
## processing container/vm kickstart additions (to a minimal kickstart)
#
cat <<EOF >> "${homedotdir}/vm-httpd/${starttime}.${mypid}.docroot/baker.ks"
%packages --default
# for retrieving files from the host httpd server and/or the internet
wget
%end

%post --log=/root/min-ks.post.log.log

# 1G of swapfile
dd if=/dev/zero of=/.swapfile bs=1M count=1024 2>&1 | tee -a /var/log/mkswap.log
mkswap /.swapfile 2>&1 | tee -a /var/log/mkswap.log

## services
/sbin/chkconfig --level=3 NetworkManager


#############################################################################
#
## rc.local appending: executed _AFTER_ install, on first boot
#
cat << FOO >> /etc/rc.d/rc.local

# disable selinux enforcement for makeworld/koji/pungi
setenforce 0

# enable swapfile
swapon /.swapfile

# let the user see terminal output if they happen to be watching a console
rhgb-client --quit
# disable console blanking since this will be a VM, not a real monitor
setterm -blank 0

# only do x-run once, not every boot
if [ ! -f /root/x-run ]; then

    # tell x-run that it is OK to overwrite /dev/sdb with its output
    touch /tmp/disk-sdb-is-going-to-get-overwritten

    # pull task to run from qemu-kvm host running el-build spawned httpd on port 8421
    wget -O /root/x-run http://10.0.2.2:8421/x-run
    chmod +x /root/x-run
    # TODO: x-run uses the installed yum.repos.d, which do not yet utilize
    #       available mirrors (cough, vmirmog, cough)
    ( ( /root/x-run ; init 0 ) 2>&1 | tee -a /root/x-run.log ) &
fi

FOO
#
## end post-install rc.local appendage
#
#############################################################################

%end
EOF

# TODO perhaps improve with definable/option for bootstrap_repotree
# TODO more general/flexible mirror support ala viros' vmirmog etc...  (too complex for now)
sed -i \
    -e 's|ftp://ftp.scientificlinux.org/linux/scientific/6.0/x86_64/os|http://10.0.2.2:8421/cache/ftp.scientificlinux.org___linux__scientific__6.0__x86_64__os|' \
    "${homedotdir}/vm-httpd/${starttime}.${mypid}.docroot/baker.ks"

#
## end processing container/vm kickstart additions
#
#############################################################################


#############################################################################
#
## create throwaway vm disk image
#

status "creating new system disk image files for the inner-vm ..."
# TODO: x_eval wrapper for logging (ala viros' 'veva' function)
qemu-img create \
    "${bvm_tmpdir}/sysroot.img" \
    "${x_builder_vm_root_fs_size}" \
    >> "${bvm_tmpdir}/qemu-img-create.log" 2>&1

qemu-img create \
    "${bvm_tmpdir}/output.img" \
    "${x_builder_vm_output_fs_size}" \
    >> "${bvm_tmpdir}/qemu-img-create.log" 2>&1

qemu-img create \
    "${bvm_tmpdir}/scratch.img" \
    "${x_builder_vm_scratch_fs_size}" \
    >> "${bvm_tmpdir}/qemu-img-create.log" 2>&1


#############################################################################
#
## check for cached copy of throwaway vm
#

# see if cached copy exists by calculating filename based on sha256 checksum
vm_cfg_checksum=$( sha256sum \
    "${homedotdir}/vm-httpd/${starttime}.${mypid}.docroot/baker.ks" \
    | awk '{print $1}')

if [ -f "${cachedir}/vm-${vm_cfg_checksum}.img" ]; then

    status "found acceptable cached system image, duplicating ..."

    rm -f "${bvm_tmpdir}/sysroot.img"

    cp -a --sparse=always \
	"${cachedir}/vm-${vm_cfg_checksum}.img" \
	"${bvm_tmpdir}/sysroot.img"

    touch "${bvm_tmpdir}/sysroot.img.fromcache"

    virt-install \
	--import \
	--name="${progname}-${starttime}-${mypid}" \
	--disk="${bvm_tmpdir}/sysroot.img" \
	--disk="${bvm_tmpdir}/output.img" \
	--disk="${bvm_tmpdir}/scratch.img" \
	--ram="${x_builder_vm_memory}" \
	--noreboot \
	--wait=-1 \
	--noautoconsole \
	> "${bvm_tmpdir}/virt-install.log" 2>&1

else

#############################################################################
#
## run netinst(all) on/to throwaway vm disk image
#

# TODO: add standard qemu (not provided by tuv's repos) as fallback for
#       an x32 build option, or e.g. my amd-sempron3400+ no-amd-svm case

#       for the netinst here (just boot.iso? or does virt-install pull the
#       kernel and initrd from PXE/pxeboot directories?)
#
# TODO: or as an interim measure to the above, and not a bad idea otherwise,
#       just checksum the entire net cache directory and include that in the
#       build logs tarball somewhere, and add a checksum of the build logs
#       tarball to the main output checksums which get signed.

# TODO: make --noautoconsole a --quiet/--debug/--verbose kind of thing

# TODO: factor --location into x_baker_os config var or such    

    os_location="${cachedir}/ftp.scientificlinux.org___linux__scientific__6.0__x86_64__os"

    # note: I have a feeling SL may change out these files from time to time.  Hopefully
    #       they are done changing 6.0, but if they do update it in the future, some better
    #       mechanism should be used.  Perhaps the simplest would be to verify against the
    #       dated in filename netinst .iso and extract the vmlinuz and initrd.img from there
    #       overwriting the pxe ones currently used.
    status "verifying hash/signatures of baker os installation kernel and initramfs ..."
    if [ "$( sha512sum ${os_location}/images/pxeboot/vmlinuz | awk '{print $1}' )" != \
	"${x_bake_vm_os_installer_kernel_hash}" ]; then
	die "baker os installation kernel had the wrong hash/signature (see note in bake script code)"
    fi
    if [ "$( sha512sum ${os_location}/images/pxeboot/initrd.img | awk '{print $1}' )" != \
	"${x_bake_vm_os_installer_initramfs_hash}" ]; then
	die "baker os installation initramfs had the wrong hash/signature (see note in bake script code)"
    fi

    status "launching inner-vm installation (domain:${progname}-${starttime}-${mypid}) ..."
    status "note: use 'el-build view-last-bake-vm' to get a console view of the installation ..."
    virt-install \
	--name="${progname}-${starttime}-${mypid}" \
	--location="${os_location}" \
	--disk="${bvm_tmpdir}/sysroot.img" \
	--disk="${bvm_tmpdir}/output.img" \
	--disk="${bvm_tmpdir}/scratch.img" \
	--ram="${x_builder_vm_memory}" \
	--noreboot \
	--wait=-1 \
	--noautoconsole \
	-x "ks=http://${x_builder_vm_host_ip}:${x_builder_user_httpd_port}/baker.ks" \
	> "${bvm_tmpdir}/virt-install.log" 2>&1


    # cache a pristine copy for future runs
    # note: could use qemu-img or other snapshots, but those may have performance issues
    status "stashing a duplicate of the freshly installed vm in the cache ..."
    cp -a --sparse=always \
	"${bvm_tmpdir}/sysroot.img" \
	"${cachedir}/vm-${vm_cfg_checksum}.img"
fi


#############################################################################
#
## run throwaway vm for main/inner processing/build phase
#

## todo: have all virt runs log through simple text channel to console, i.e.
##       console over serial port, or ssh/netcat logfile streaming...

status "saving inner-vm's virtualization domain information ..."
virsh \
    dumpxml \
    "${progname}-${starttime}-${mypid}" \
    > "${bvm_tmpdir}/vdomain.xml"

# TODO: get logging to native terminal/logfile via some pipe.
#       i.e. could listen with netcat or ssh and have inner-vm
#       send its x-run.log output via that.

status "launching inner-vm's processing phase ..."
virsh \
    start \
    "${progname}-${starttime}-${mypid}" \
    > "${bvm_tmpdir}/virt-run.log" 2>&1

status "waiting a few seconds for inner-vm to come online ..."
sleep 24

# TODO: make this a --debug only thing
status "debug/viewing inner-vm console ..."
view-last-bake-vm &

status "waiting for inner-vm to finish processing ..."
# wait until processing is complete
xdone=0
while ((! ${xdone})); do
    sleep "${x_builder_vm_shutdown_polling_frequency}"
    if $( ! virsh list | grep "${progname}-${starttime}-${mypid}" | grep -q running ); then
	xdone=1
    fi
done


#############################################################################
#
## arrange output for user, clean up, and exit
#

status "arranging output for the user ..."
tar \
    -C "${outputdir}" \
    -xvf "${bvm_tmpdir}/output.img"

# todo: invoke populate-staging-repo here, or perhaps within v-bake

status "cleaning up ..."

# leave it around for development/debugging, it'll get cleaned out
# by a subsequent run (see x_keep_old_baker_vm_definitions default)
#virsh \
#    undefine \
#    "${progname}-${starttime}-${mypid}"


status "done."
exit 0

#############################################################################
## end script - only notes below
#############################################################################
#
#
#

